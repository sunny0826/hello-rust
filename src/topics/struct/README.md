# 结构体（struct）

结构体（struct）是 Rust 中的一个核心概念，用于创建自定义数据类型。

## 1. 定义结构体

结构体使用 `struct` 关键字定义，后跟结构体的名称和一系列字段。每个字段都有一个名称和一个类型。

```rust
struct Point {
    x: i32,
    y: i32,
}
```

## 2. 实例化结构体

一旦定义了结构体，你可以创建其实例：

```rust
let origin = Point { x: 0, y: 0 };
```

## 3. 访问结构体字段

你可以使用点符号 `.` 来访问结构体的字段：

```rust
let x_value = origin.x;
let y_value = origin.y;
```

## (*)4. 可变结构体实例

默认情况下，结构体实例是不可变的。但是，你可以使用 `mut` 关键字创建一个可变的结构体实例，并修改其字段：

```rust
let mut point = Point { x: 0, y: 0 };
point.x = 5;
```

## 5. 结构体更新语法

当创建一个结构体实例时，如果你想从另一个实例复制某些字段的值，可以使用结构体更新语法：

```rust
let point2 = Point { x: 10, ..point };
```

上面的代码创建了一个新的 `Point` 实例，其中 `x` 字段的值为 10，而 `y` 字段的值与 `point` 实例的 `y` 字段相同。

## 6. 元组结构体

元组结构体与常规结构体类似，但其字段没有名称，只有类型：

```rust
struct Color(i32, i32, i32);

let red = Color(255, 0, 0);
```

你可以使用模式匹配或点符号加索引来访问元组结构体的字段：

```rust
let Color(r, g, b) = red;
let blue_value = red.2;
```

## 7. 单位结构体

没有字段的结构体称为单位结构体。它们可以用作泛型类型的占位符：

```rust
struct Unit;
```

## 8. 结构体方法

当然可以！结构体方法是定义在结构体上的函数，它们可以访问和修改结构体实例的数据。以下是关于结构体方法的详细介绍：

### 1. 定义方法

要为结构体定义方法，你需要使用 `impl` 关键字创建一个实现块。在此块中，你可以定义方法，这些方法可以接受一个结构体实例作为其第一个参数。

```rust
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn display(&self) {
        println!("Point({}, {})", self.x, self.y);
    }
}
```

在上面的例子中，`display` 是一个方法，它接受一个 `Point` 的不可变引用作为参数。

### 2. `self` 参数

结构体方法的第一个参数总是 `self`，它代表调用方法的结构体实例。`self` 可以是以下三种形式之一：

- `self`: 这是一个结构体的值。这意味着方法获取了结构体的所有权。
- `&self`: 这是一个结构体的不可变引用。这意味着方法可以读取但不能修改结构体。
- `&mut self`: 这是一个结构体的可变引用。这意味着方法可以修改结构体。

### 3. 调用方法

要调用结构体的方法，你需要使用点符号 `.`：

```rust
let p = Point { x: 5, y: 10 };
p.display();
```

### 4. 方法与可变性

如果你想在方法中修改结构体，你需要使用 `&mut self` 作为第一个参数，并确保调用该方法的结构体实例是可变的：

```rust
impl Point {
    fn move_right(&mut self, distance: i32) {
        self.x += distance;
    }
}

let mut p = Point { x: 5, y: 10 };
p.move_right(5);
```

### 5. 返回结构体实例

方法可以返回结构体实例或其引用：

```rust
impl Point {
    fn new(x: i32, y: i32) -> Self {
        Point { x, y }
    }

    fn clone(&self) -> Self {
        Point { x: self.x, y: self.y }
    }
}

let p1 = Point::new(5, 10);
let p2 = p1.clone();
```

在上面的例子中，`new` 是一个关联函数（因为它不接受 `self` 参数），而 `clone` 是一个方法。

### 6. 链式方法调用

如果方法返回一个结构体的可变引用，你可以进行链式方法调用：

```rust
impl Point {
    fn move_up(&mut self, distance: i32) -> &mut Self {
        self.y += distance;
        self
    }
}

let mut p = Point { x: 5, y: 10 };
p.move_right(5).move_up(10);
```

### 结构体方法总结

结构体方法提供了一种在结构体实例上操作数据的方法。它们类似于其他编程语言中的类方法，但在 Rust 中，方法的可变性、所有权和借用规则使其具有独特的特点。这些规则确保了内存安全和数据完整性。

## 9. 关联函数

关联函数是定义在结构体、枚举或 trait 的 `impl` 块中的函数，但它们不接受 `self` 参数。因为它们不作用于实例，所以它们也被称为静态方法。以下是关于关联函数的详细介绍：

### 1. 定义关联函数

关联函数在 `impl` 块中定义，与常规方法一样，但它们不接受 `self` 参数。

```rust
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    // 这是一个关联函数
    fn origin() -> Point {
        Point { x: 0, y: 0 }
    }
}
```

### 2. 调用关联函数

关联函数使用 `::` 语法调用，而不是点符号 `.`。

```rust
let starting_point = Point::origin();
```

### 3. 用途

关联函数的常见用途是作为构造函数，创建并返回一个新的结构体或枚举实例。在上面的例子中，`origin` 函数是 `Point` 结构体的一个关联函数，它返回一个新的 `Point` 实例。

### 4. 关联函数与方法的区别

主要的区别在于它们的调用方式和参数：

- **关联函数**：不接受 `self` 参数，使用 `::` 语法调用。
- **方法**：接受 `self`、`&self` 或 `&mut self` 作为其第一个参数，使用 `.` 语法调用。

### 5. 关联函数与泛型

关联函数也可以与泛型结构体或枚举一起使用。例如：

```rust
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }
}
```

在上面的例子中，`Container` 是一个泛型结构体，`new` 是一个关联函数，用于创建一个新的 `Container` 实例。

### 关联函数总结

关联函数是定义在结构体、枚举或 trait 的 `impl` 块中的函数，它们不接受 `self` 参数。它们通常用作构造函数，但也可以用于执行与特定类型相关但不依赖于特定实例的任何操作。关联函数提供了一种组织与特定类型相关的函数的方法，而不需要创建该类型的实例。

## 总结

结构体是 Rust 中创建自定义数据类型的主要方式。它们提供了一种组织和管理相关数据的方法，并可以与方法和关联函数一起使用，以提供与数据相关的功能。结构体是 Rust 中面向对象编程的基石，与其他语言中的类有些相似，但也有其独特之处。
