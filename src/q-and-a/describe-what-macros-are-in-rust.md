# Describe what macros are in Rust

> 请描述 Rust 中宏是什么，以及它与普通函数有何不同？另外，能否给出一个简单的宏定义和使用的示例？

在 Rust 中，宏提供了一种在编译时进行代码生成的方法。它们允许你写下一些类似于函数调用的代码，但在编译时这些代码会展开成更多的代码。

1. **宏与函数的区别**：
   - **编译时 vs 运行时**：宏在编译时展开，而函数在运行时执行。
   - **代码生成**：宏可以生成大量的代码，这在函数中是不可能的。
   - **类型安全**：由于宏在编译时展开，它们可以为各种类型生成特定的代码，而不需要泛型或运行时类型检查。
   - **语法**：宏定义和调用的语法与普通函数不同。

2. **示例**：

   定义一个简单的宏，用于计算任意数量的数字的和：

   ```rust
   macro_rules! sum {
       ($($x:expr),*) => {
           {
               let mut total = 0;
               $(
                   total += $x;
               )*
               total
           }
       };
   }

   fn main() {
       let result = sum!(1, 2, 3, 4, 5);
       println!("The sum is: {}", result);  // 输出 "The sum is: 15"
   }
   ```

   在上面的示例中，我们定义了一个 `sum!` 宏，它接受任意数量的表达式，并生成代码来计算它们的和。在 `main` 函数中，我们调用了这个宏并传入了五个数字，然后打印了结果。

总的来说，宏提供了一种强大的方式来在编译时生成代码，这使得你可以编写更加灵活和高效的 Rust 代码。
